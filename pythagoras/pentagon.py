from sympy import cancel, expand, gcd_list, symbols
from homogeneous import *

def circle(P1, P2, P3):
    # return (a, d, e, f) such that a*x**2 + a*y**2 + d*x*z + e*y*z + f*z**2 = 0 is the circle's equation
    x, y, z = symbols('x, y, z')
    (x1, y1, z1), (x2, y2, z2), (x3, y3, z3) = P1, P2, P3
    # generated by homogeneous-circle.py
    a = expand(x1*y2*z1*z2*z3**2 - x1*y3*z1*z2**2*z3 - x2*y1*z1*z2*z3**2 + x2*y3*z1**2*z2*z3 + x3*y1*z1*z2**2*z3 - x3*y2*z1**2*z2*z3)
    d = expand(-x1**2*y2*z2*z3**2 + x1**2*y3*z2**2*z3 + x2**2*y1*z1*z3**2 - x2**2*y3*z1**2*z3 - x3**2*y1*z1*z2**2 + x3**2*y2*z1**2*z2 - y1**2*y2*z2*z3**2 + y1**2*y3*z2**2*z3 + y1*y2**2*z1*z3**2 - y1*y3**2*z1*z2**2 - y2**2*y3*z1**2*z3 + y2*y3**2*z1**2*z2)
    e = expand(x1**2*x2*z2*z3**2 - x1**2*x3*z2**2*z3 - x1*x2**2*z1*z3**2 + x1*x3**2*z1*z2**2 - x1*y2**2*z1*z3**2 + x1*y3**2*z1*z2**2 + x2**2*x3*z1**2*z3 - x2*x3**2*z1**2*z2 + x2*y1**2*z2*z3**2 - x2*y3**2*z1**2*z2 - x3*y1**2*z2**2*z3 + x3*y2**2*z1**2*z3)
    f = expand(-x1**2*x2*y3*z2*z3 + x1**2*x3*y2*z2*z3 + x1*x2**2*y3*z1*z3 - x1*x3**2*y2*z1*z2 + x1*y2**2*y3*z1*z3 - x1*y2*y3**2*z1*z2 - x2**2*x3*y1*z1*z3 + x2*x3**2*y1*z1*z2 - x2*y1**2*y3*z2*z3 + x2*y1*y3**2*z1*z2 + x3*y1**2*y2*z2*z3 - x3*y1*y2**2*z1*z3)
    gcd = gcd_list([a, d, e, f])
    return cancel(a/gcd), cancel(d/gcd), cancel(e/gcd), cancel(f/gcd)

def on_circle(C, P):
    (a, d, e, f), (x, y, z) = C, P
    return expand(a*(x**2 + y**2) + d*x*z + e*y*z + f*z**2) == 0

def perpendicular(A, B, P):
    # return (u, v, w) such that u*x + v*y + w*z = 0 is perpendicular to AB and passes through P
    (x1, y1, z1), (x2, y2, z2), (x3, y3, z3) = A, B, P
    u, v = x1*z2 - x2*z1, y1*z2 - y2*z1
    return reduced(u*z3, v*z3, -u*x3 - v*y3)

def intersect(C1, C2, P1):
    # return another intersection P2 of circles C1 and C2
    assert on_circle(C1, P1) and on_circle(C2, P1)
    CC1, CC2 = reduced(-C1[1], -C1[2], 2*C1[0]), reduced(-C2[1], -C2[2], 2*C2[0])
    C1C2, P1P2 = cross(CC1, CC2), perpendicular(CC1, CC2, P1)
    M = cross(C1C2, P1P2)
    (x1, y1, z1), (x2, y2, z2) = P1, M
    P2 = reduced(2*x2*z1 - x1*z2, 2*y2*z1 - y1*z2, z1*z2)
    assert on_circle(C1, P2) and on_circle(C2, P2)
    return P2

def circle_eq(C):
    return f'({C[0]})*x**2 + ({C[0]})*y**2 + ({C[1]})*x*z + ({C[2]})*y*z + ({C[3]})*z**2 = 0'

def main():
    # https://en.wikipedia.org/wiki/Five_circles_theorem
    a, b, c, d, e, f, g = symbols('a, b, c, d, e, f, g')
    A0A1, A1A2, A2A3, A3A4, A4A0 = (1, 0, 0), (a, 1, 0), (b, c, 1), (d, e, 1), (f, g, 1)
    A0, A1, A2, A3, A4 = cross(A4A0, A0A1), cross(A0A1, A1A2), cross(A1A2, A2A3), cross(A2A3, A3A4), cross(A3A4, A4A0)
    B0, B1, B2, B3, B4 = cross(A1A2, A3A4), cross(A2A3, A4A0), cross(A3A4, A0A1), cross(A4A0, A1A2), cross(A0A1, A2A3)
    A2B0A3, A3B1A4, A4B2A0, A0B3A1, A1B4A2 = circle(A2, B0, A3), circle(A3, B1, A4), circle(A4, B2, A0), circle(A0, B3, A1), circle(A1, B4, A2)
    print('A2B0A3:', circle_eq(A2B0A3))
    print('A3B1A4:', circle_eq(A3B1A4))
    print('A4B2A0:', circle_eq(A4B2A0))
    print('A0B3A1:', circle_eq(A0B3A1))
    print('A1B4A2:', circle_eq(A1B4A2))
    C4 = intersect(A3B1A4, A4B2A0, A4)
    print('C4:', C4, flush = True)
    C0 = intersect(A4B2A0, A0B3A1, A0)
    print('C0:', C0, flush = True)
    C1 = intersect(A0B3A1, A1B4A2, A1)
    print('C1:', C1, flush = True)
    C2 = intersect(A1B4A2, A2B0A3, A2)
    print('C2:', C2, flush = True)
    # C0C1C2 = circle(C0, C1, C2)
    # print('C0C1C2:', circle_eq(C0C1C2), flush = True)
    # print('Is C4 on C0C1C2?', on_circle(C0C1C2, C4), flush = True)

if __name__ == '__main__':
    main()